<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Control Tasmota</title>
    
    <!-- Meta tags para APK -->
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Control Tasmota">
    <meta name="mobile-web-app-capable" content="yes">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 5px;
            color: #333;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            overflow-x: hidden;
        }

        .container {
            max-width: 420px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
            min-height: calc(100vh - 10px);
            position: relative;
        }

        .header {
            text-align: center;
            margin-bottom: 15px;
            padding: 10px 0;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header h1 {
            color: #4a5568;
            font-size: 22px;
            font-weight: 700;
            margin-bottom: 8px;
            text-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .connection-status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            margin-top: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .status-connected {
            background: linear-gradient(135deg, #c6f6d5, #9ae6b4);
            color: #2f855a;
        }

        .status-disconnected {
            background: linear-gradient(135deg, #fed7d7, #feb2b2);
            color: #c53030;
        }

        .status-connecting {
            background: linear-gradient(135deg, #fef5e7, #f6e05e);
            color: #d69e2e;
        }

        .temp-display {
            background: linear-gradient(135deg, #4299e1, #3182ce);
            color: white;
            padding: 25px;
            border-radius: 20px;
            text-align: center;
            margin-bottom: 15px;
            box-shadow: 0 10px 30px rgba(66, 153, 225, 0.4);
            position: relative;
            overflow: hidden;
        }

        .temp-display h2 {
            font-size: 32px;
            font-weight: 700;
            position: relative;
            z-index: 1;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .temp-unit {
            font-size: 14px;
            opacity: 0.9;
            margin-top: 8px;
            position: relative;
            z-index: 1;
        }

        .mode-display {
            background: linear-gradient(135deg, #48bb78, #38a169);
            color: white;
            padding: 16px;
            border-radius: 16px;
            text-align: center;
            margin-bottom: 15px;
            font-size: 16px;
            font-weight: 600;
            box-shadow: 0 8px 25px rgba(72, 187, 120, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        .countdown-display {
            background: linear-gradient(135deg, #ed8936, #dd6b20);
            color: white;
            padding: 14px;
            border-radius: 16px;
            text-align: center;
            margin-bottom: 15px;
            font-size: 16px;
            font-weight: 600;
            display: none;
            box-shadow: 0 8px 25px rgba(237, 137, 54, 0.4);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.02); opacity: 0.9; }
        }

        .config-section {
            background: linear-gradient(135deg, #f8fafc, #edf2f7);
            padding: 18px;
            border-radius: 16px;
            margin-bottom: 15px;
            border: 1px solid #e2e8f0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }

        .config-title {
            font-size: 14px;
            font-weight: 700;
            color: #4a5568;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .input-row {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
        }

        .input-group {
            flex: 1;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 12px;
            color: #4a5568;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 16px;
            transition: all 0.3s ease;
            background: white;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
        }

        .input-group input:focus {
            outline: none;
            border-color: #4299e1;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.1), inset 0 2px 4px rgba(0,0,0,0.05);
            transform: translateY(-1px);
        }

        .button {
            width: 100%;
            padding: 16px;
            border: none;
            border-radius: 16px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
        }

        .button:active {
            transform: translateY(1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }

        .btn-mode {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .btn-update {
            background: linear-gradient(135deg, #4299e1, #3182ce);
            color: white;
        }

        .btn-on {
            background: linear-gradient(135deg, #48bb78, #38a169);
            color: white;
        }

        .btn-off {
            background: linear-gradient(135deg, #f56565, #e53e3e);
            color: white;
        }

        .status-indicator {
            display: inline-block;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            position: relative;
            box-shadow: 0 0 10px currentColor;
        }

        .status-on {
            background: #48bb78;
            animation: blink-green 2s ease-in-out infinite;
        }

        .status-off {
            background: #f56565;
        }

        .status-unknown {
            background: #a0aec0;
            animation: fade 2s ease-in-out infinite;
        }

        @keyframes blink-green {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes fade {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        .status-indicator::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: white;
        }

        .error-message, .success-message {
            padding: 14px;
            border-radius: 12px;
            margin-bottom: 15px;
            font-size: 14px;
            font-weight: 500;
            animation: slideIn 0.3s ease-out;
        }

        .error-message {
            background: linear-gradient(135deg, #fed7d7, #feb2b2);
            color: #c53030;
            border-left: 4px solid #f56565;
        }

        .success-message {
            background: linear-gradient(135deg, #c6f6d5, #9ae6b4);
            color: #2f855a;
            border-left: 4px solid #48bb78;
        }

        @keyframes slideIn {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .button-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 15px;
        }

        .loading {
            position: relative;
            pointer-events: none;
        }

        .loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin: -10px 0 0 -10px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .version-info {
            text-align: center;
            padding: 10px;
            font-size: 12px;
            color: #718096;
            border-top: 1px solid #e2e8f0;
            margin-top: 20px;
        }

        .debug-info {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            font-size: 11px;
            font-family: monospace;
            color: #4a5568;
            max-height: 200px;
            overflow-y: auto;
        }

        /* Responsive para pantallas muy peque√±as */
        @media (max-width: 380px) {
            .container {
                padding: 12px;
                margin: 2px;
                border-radius: 15px;
            }
            
            .input-row {
                flex-direction: column;
                gap: 12px;
            }
            
            .temp-display h2 {
                font-size: 28px;
            }
            
            .button {
                padding: 14px;
                font-size: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üå°Ô∏è Control Tasmota</h1>
            <div class="connection-status status-disconnected" id="connectionStatus">
                üî¥ Desconectado
            </div>
        </div>

        <div id="messages"></div>

        <div class="temp-display">
            <h2 id="lblTempActual">-- ¬∞C</h2>
            <div class="temp-unit" id="lastUpdate">Iniciando...</div>
        </div>

        <div class="mode-display" id="lblModo">
            <span>Modo: Autom√°tico</span>
            <span class="status-indicator status-unknown" id="statusIndicator"></span>
        </div>

        <div class="countdown-display" id="lblCooldown"></div>

        <div class="config-section">
            <div class="config-title">‚öôÔ∏è Configuraci√≥n del Dispositivo</div>
            <div class="input-group">
                <label for="deviceIP">IP del Tasmota:</label>
                <input type="text" id="deviceIP" value="192.168.1.16" placeholder="192.168.1.100" inputmode="url">
            </div>
        </div>

        <div class="config-section">
            <div class="config-title">üéØ Control de Temperatura</div>
            <div class="input-row">
                <div class="input-group">
                    <label for="txtTempObjetivo">Objetivo (¬∞C):</label>
                    <input type="number" id="txtTempObjetivo" value="4" step="0.1" min="-20" max="50" inputmode="decimal">
                </div>
                <div class="input-group">
                    <label for="txtDescanso">Descanso (s):</label>
                    <input type="number" id="txtDescanso" value="180" min="30" max="3600" inputmode="numeric">
                </div>
            </div>
        </div>

        <button class="button btn-mode" id="btnCambiarModo">Cambiar a Manual</button>
        <button class="button btn-update" id="btnActualizar">üîÑ Actualizar Ahora</button>
        
        <div class="button-grid">
            <button class="button btn-on" id="btnEncender">üü¢ Encender</button>
            <button class="button btn-off" id="btnApagar">üî¥ Apagar</button>
        </div>

        <div class="debug-info" id="debugInfo">Esperando datos...</div>

        <div class="version-info">
            Control Tasmota v2.3 - DS18B20 Mejorado
        </div>
    </div>

    <script>
        // Variables globales simplificadas
        let tempActual = null;
        let modoAutomatico = true;
        let ultimoApagado = null;
        let enDescanso = false;
        let descanso = 180;
        let objetivo = 4;
        let relayStatus = 'unknown';
        let isConnected = false;
        let readingTimer = null;
        let uiTimer = null;
        let lastSuccessfulRead = null;

        // Elementos DOM
        const lblTempActual = document.getElementById('lblTempActual');
        const lblModo = document.getElementById('lblModo');
        const lblCooldown = document.getElementById('lblCooldown');
        const btnCambiarModo = document.getElementById('btnCambiarModo');
        const btnActualizar = document.getElementById('btnActualizar');
        const btnEncender = document.getElementById('btnEncender');
        const btnApagar = document.getElementById('btnApagar');
        const txtTempObjetivo = document.getElementById('txtTempObjetivo');
        const txtDescanso = document.getElementById('txtDescanso');
        const deviceIP = document.getElementById('deviceIP');
        const statusIndicator = document.getElementById('statusIndicator');
        const connectionStatus = document.getElementById('connectionStatus');
        const lastUpdate = document.getElementById('lastUpdate');
        const messages = document.getElementById('messages');
        const debugInfo = document.getElementById('debugInfo');

        // Funciones de utilidad
        function showMessage(text, type = 'error') {
            const messageEl = document.createElement('div');
            messageEl.className = `${type}-message`;
            messageEl.textContent = text;
            messages.appendChild(messageEl);
            
            setTimeout(() => {
                if (messageEl.parentNode) {
                    messageEl.parentNode.removeChild(messageEl);
                }
            }, 4000);
        }

        function updateConnectionStatus(connected) {
            isConnected = connected;
            const statusEl = connectionStatus;
            
            if (connected) {
                statusEl.className = 'connection-status status-connected';
                statusEl.textContent = 'üü¢ Conectado';
            } else {
                statusEl.className = 'connection-status status-disconnected';
                statusEl.textContent = 'üî¥ Desconectado';
            }
        }

        function setConnecting() {
            connectionStatus.className = 'connection-status status-connecting';
            connectionStatus.textContent = 'üü° Conectando...';
        }

        function updateStatusIndicator() {
            statusIndicator.className = 'status-indicator';
            if (relayStatus === 'ON') {
                statusIndicator.classList.add('status-on');
            } else if (relayStatus === 'OFF') {
                statusIndicator.classList.add('status-off');
            } else {
                statusIndicator.classList.add('status-unknown');
            }
        }

        function setButtonLoading(button, loading) {
            if (loading) {
                button.classList.add('loading');
                button.disabled = true;
            } else {
                button.classList.remove('loading');
                button.disabled = false;
            }
        }

        function addDebugInfo(text) {
            const now = new Date().toLocaleTimeString();
            debugInfo.innerHTML += `[${now}] ${text}<br>`;
            debugInfo.scrollTop = debugInfo.scrollHeight;
            console.log(`[DEBUG] ${text}`);
        }

        // Funci√≥n mejorada para leer temperatura y estado
        async function leerDatos() {
            const ip = deviceIP.value.trim();
            if (!ip) {
                showMessage('Por favor ingresa la IP del dispositivo');
                addDebugInfo('Error: IP no configurada');
                return;
            }

            setConnecting();
            addDebugInfo(`Conectando a ${ip}...`);

            try {
                // Primero obtener datos del sensor
                await obtenerTemperatura(ip);
                // Luego obtener estado del power
                await obtenerEstadoPower(ip);
                
            } catch (error) {
                addDebugInfo(`Error general: ${error.message}`);
                updateConnectionStatus(false);
                showMessage(`Error: ${error.message}`);
                lblTempActual.textContent = '-- ¬∞C';
                lastUpdate.textContent = 'Error de conexi√≥n';
            }
        }

        async function obtenerTemperatura(ip) {
            // Comando espec√≠fico para obtener datos de sensores
            const sensorUrl = `http://${ip}/cm?cmnd=Status%208`;
            addDebugInfo(`Obteniendo sensores: ${sensorUrl}`);
            
            try {
                let response = await fetchWithFallback(sensorUrl);
                addDebugInfo(`Respuesta raw: ${response.substring(0, 200)}...`);
                
                let data = JSON.parse(response);
                addDebugInfo(`Datos parseados: ${JSON.stringify(data, null, 2)}`);
                
                let temperatura = null;
                let sensorId = null;
                
                // Verificar estructura exacta que reportaste: StatusSNS.DS18B20.Temperature
                if (data && data.StatusSNS && data.StatusSNS.DS18B20) {
                    addDebugInfo(`DS18B20 encontrado en StatusSNS`);
                    
                    // Obtener ID del sensor si existe
                    if (data.StatusSNS.DS18B20.Id) {
                        sensorId = data.StatusSNS.DS18B20.Id;
                        addDebugInfo(`ID del sensor: ${sensorId}`);
                    }
                    
                    // Obtener temperatura directamente
                    if (typeof data.StatusSNS.DS18B20.Temperature !== 'undefined') {
                        temperatura = parseFloat(data.StatusSNS.DS18B20.Temperature);
                        addDebugInfo(`‚úÖ DS18B20 temperatura encontrada: ${temperatura}¬∞C`);
                    } else {
                        addDebugInfo(`‚ùå Propiedad Temperature no encontrada en DS18B20`);
                        addDebugInfo(`Propiedades disponibles: ${Object.keys(data.StatusSNS.DS18B20).join(', ')}`);
                    }
                } else {
                    addDebugInfo(`‚ùå Estructura DS18B20 no encontrada en StatusSNS`);
                    
                    if (data && data.StatusSNS) {
                        addDebugInfo(`Sensores disponibles en StatusSNS: ${Object.keys(data.StatusSNS).join(', ')}`);
                        
                        // Buscar cualquier sensor con temperatura
                        for (const [key, value] of Object.entries(data.StatusSNS)) {
                            addDebugInfo(`Examinando sensor: ${key} = ${JSON.stringify(value)}`);
                            if (typeof value === 'object' && value !== null && typeof value.Temperature !== 'undefined') {
                                temperatura = parseFloat(value.Temperature);
                                addDebugInfo(`‚úÖ Temperatura encontrada en ${key}: ${temperatura}¬∞C`);
                                break;
                            }
                        }
                    } else {
                        addDebugInfo(`‚ùå No se encontr√≥ StatusSNS en la respuesta`);
                    }
                }

                // Validar temperatura encontrada
                if (temperatura !== null && !isNaN(temperatura) && temperatura > -50 && temperatura < 100) {
                    tempActual = temperatura;
                    lblTempActual.textContent = `${tempActual.toFixed(1)} ¬∞C`;
                    lastSuccessfulRead = new Date();
                    lastUpdate.textContent = `DS18B20 ${sensorId ? '(' + sensorId.slice(-4) + ')' : ''}: ${lastSuccessfulRead.toLocaleTimeString()}`;
                    updateConnectionStatus(true);
                    
                    addDebugInfo(`üéØ Temperatura actualizada exitosamente: ${tempActual.toFixed(1)}¬∞C`);
                    showMessage(`üå°Ô∏è ${tempActual.toFixed(1)}¬∞C ${sensorId ? '(ID: ...' + sensorId.slice(-4) + ')' : ''}`, 'success');
                } else {
                    addDebugInfo(`‚ùå Temperatura inv√°lida: ${temperatura}`);
                    throw new Error(`Temperatura inv√°lida: ${temperatura}`);
                }
                
            } catch (parseError) {
                addDebugInfo(`‚ùå Error parsing JSON: ${parseError.message}`);
                addDebugInfo(`Respuesta completa: ${response}`);
                throw new Error(`Error procesando datos del sensor: ${parseError.message}`);
            }
        }

        async function obtenerEstadoPower(ip) {
            const powerUrl = `http://${ip}/cm?cmnd=Power`;
            addDebugInfo(`Obteniendo estado power: ${powerUrl}`);
            
            try {
                let response = await fetchWithFallback(powerUrl);
                let data = JSON.parse(response);
                
                addDebugInfo(`Estado power: ${JSON.stringify(data)}`);
                
                if (data.POWER !== undefined) {
                    relayStatus = data.POWER;
                    updateStatusIndicator();
                    addDebugInfo(`Power status: ${relayStatus}`);
                    
                    // Control autom√°tico si est√° habilitado
                    if (modoAutomatico && tempActual !== null) {
                        controlAutomatico();
                    }
                }
                
            } catch (error) {
                addDebugInfo(`Error obteniendo power: ${error.message}`);
                // No lanzar error, el power no es cr√≠tico para la temperatura
            }
        }

        async function fetchWithFallback(url) {
            addDebugInfo(`üåê Intentando: ${url}`);
            
            try {
                // Intento directo primero
                const response = await fetch(url, {
                    method: 'GET',
                    mode: 'cors',
                    headers: { 
                        'Accept': 'application/json',
                        'Cache-Control': 'no-cache'
                    },
                    signal: AbortSignal.timeout(8000)
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const text = await response.text();
                addDebugInfo(`‚úÖ Conexi√≥n directa exitosa (${text.length} chars)`);
                return text;
                
            } catch (corsError) {
                addDebugInfo(`‚ùå Error directo: ${corsError.name} - ${corsError.message}`);
                
                // Si es un error de red/CORS, intentar con proxy
                if (corsError.name === 'TypeError' || corsError.message.includes('CORS') || corsError.message.includes('Failed to fetch')) {
                    addDebugInfo(`üîÑ Intentando con proxy...`);
                    
                    try {
                        const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
                        const proxyResponse = await fetch(proxyUrl, {
                            signal: AbortSignal.timeout(15000),
                            headers: {
                                'Accept': 'application/json'
                            }
                        });
                        
                        if (!proxyResponse.ok) {
                            throw new Error(`Proxy HTTP ${proxyResponse.status}: ${proxyResponse.statusText}`);
                        }
                        
                        const proxyData = await proxyResponse.json();
                        if (!proxyData.contents || proxyData.contents.trim() === '') {
                            throw new Error('Respuesta vac√≠a del proxy');
                        }
                        
                        addDebugInfo(`‚úÖ Conexi√≥n por proxy exitosa (${proxyData.contents.length} chars)`);
                        return proxyData.contents;
                        
                    } catch (proxyError) {
                        addDebugInfo(`‚ùå Error proxy: ${proxyError.message}`);
                        throw new Error(`Fall√≥ conexi√≥n directa y proxy: ${corsError.message} / ${proxyError.message}`);
                    }
                } else {
                    // Re-lanzar errores que no son de conectividad
                    throw corsError;
                }
            }
        }

        // Funci√≥n simplificada para enviar comandos
        async function enviarComando(comando) {
            const ip = deviceIP.value.trim();
            if (!ip) {
                showMessage('Por favor configura la IP del dispositivo');
                return false;
            }

            addDebugInfo(`Enviando comando: ${comando}`);

            try {
                const url = `http://${ip}/cm?cmnd=Power%20${comando}`;
                await fetchWithFallback(url);
                
                addDebugInfo(`Comando ${comando} ejecutado exitosamente`);
                showMessage(`‚úÖ ${comando} ejecutado`, 'success');
                
                // Actualizar estado despu√©s de 1 segundo
                setTimeout(() => obtenerEstadoPower(ip), 1000);
                
                return true;
            } catch (error) {
                addDebugInfo(`Error en comando: ${error.message}`);
                showMessage(`‚ùå Error: ${error.message}`);
                return false;
            }
        }

        function controlAutomatico() {
            if (tempActual === null) return;

            const objetivoNum = parseFloat(txtTempObjetivo.value) || 4;
            const descansoNum = parseInt(txtDescanso.value) || 180;

            addDebugInfo(`Control auto - Temp: ${tempActual}¬∞C, Objetivo: ${objetivoNum}¬∞C, Relay: ${relayStatus}`);

            // L√≥gica simple de hist√©resis con banda muerta m√°s amplia
            const bandaSuperior = objetivoNum + 0.3;
            const bandaInferior = objetivoNum - 0.3;

            if (tempActual > bandaSuperior && relayStatus === 'ON') {
                addDebugInfo(`Temperatura alta (${tempActual}¬∞C > ${bandaSuperior}¬∞C) - Apagando`);
                enviarComando('Off');
                ultimoApagado = Date.now();
                enDescanso = true;
            }

            if (tempActual < bandaInferior && relayStatus === 'OFF') {
                if (enDescanso && ultimoApagado) {
                    const elapsed = Math.floor((Date.now() - ultimoApagado) / 1000);
                    if (elapsed >= descansoNum) {
                        addDebugInfo(`Descanso terminado (${elapsed}s >= ${descansoNum}s) - Encendiendo`);
                        enDescanso = false;
                        enviarComando('On');
                    } else {
                        addDebugInfo(`En descanso: ${elapsed}s/${descansoNum}s restantes`);
                    }
                } else {
                    addDebugInfo(`Temperatura baja (${tempActual}¬∞C < ${bandaInferior}¬∞C) - Encendiendo`);
                    enviarComando('On');
                }
            }
        }

        function updateUI() {
            // Actualizar valores de configuraci√≥n
            descanso = parseInt(txtDescanso.value) || 180;
            objetivo = parseFloat(txtTempObjetivo.value) || 4;
            
            // Actualizar cuenta regresiva
            if (enDescanso && ultimoApagado) {
                const elapsed = Math.floor((Date.now() - ultimoApagado) / 1000);
                const remaining = Math.max(0, descanso - elapsed);
                
                if (remaining > 0) {
                    const minutes = Math.floor(remaining / 60);
                    const seconds = remaining % 60;
                    const timeStr = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
                    
                    lblCooldown.textContent = `‚è≥ Descanso: ${timeStr}`;
                    lblCooldown.style.display = 'block';
                } else {
                    enDescanso = false;
                    lblCooldown.style.display = 'none';
                }
            } else {
                lblCooldown.style.display = 'none';
            }
        }

        function updateDisplay() {
            const modoText = modoAutomatico ? 'Autom√°tico' : 'Manual';
            const btnText = modoAutomatico ? 'Cambiar a Manual' : 'Cambiar a Autom√°tico';
            
            lblModo.innerHTML = `<span>Modo: ${modoText}</span><span class="status-indicator status-unknown" id="statusIndicator"></span>`;
            btnCambiarModo.textContent = btnText;
            
            // Reestablecer referencia al indicador
            const newIndicator = lblModo.querySelector('.status-indicator');
            if (newIndicator) {
                newIndicator.id = 'statusIndicator';
                updateStatusIndicator();
            }
        }

        function initialize() {
            addDebugInfo('üöÄ Iniciando Control Tasmota v2.3 - DS18B20 Espec√≠fico');
            addDebugInfo(`üì° Configurado para IP: ${deviceIP.value}`);
            addDebugInfo(`üéØ Objetivo: ${txtTempObjetivo.value}¬∞C, Descanso: ${txtDescanso.value}s`);
            
            updateDisplay();
            
            // Timer de lectura cada 15 segundos (m√°s tiempo para estabilidad)
            readingTimer = setInterval(leerDatos, 15000);
            uiTimer = setInterval(updateUI, 1000);
            
            // Primera lectura despu√©s de 2 segundos
            setTimeout(() => {
                addDebugInfo('üîç Iniciando primera lectura del sensor DS18B20...');
                leerDatos();
            }, 2000);
            
            showMessage('üå°Ô∏è Buscando sensor DS18B20...', 'success');
        }

        // Event Listeners
        btnCambiarModo.addEventListener('click', function() {
            modoAutomatico = !modoAutomatico;
            updateDisplay();
            addDebugInfo(`Modo cambiado a: ${modoAutomatico ? 'Autom√°tico' : 'Manual'}`);
            showMessage(modoAutomatico ? 'Modo autom√°tico activado' : 'Modo manual activado', 'success');
        });

        btnActualizar.addEventListener('click', function() {
            setButtonLoading(this, true);
            leerDatos().finally(() => setButtonLoading(this, false));
        });

        btnEncender.addEventListener('click', async function() {
            modoAutomatico = false;
            updateDisplay();
            setButtonLoading(this, true);
            await enviarComando('On');
            setButtonLoading(this, false);
        });

        btnApagar.addEventListener('click', async function() {
            modoAutomatico = false;
            updateDisplay();
            setButtonLoading(this, true);
            await enviarComando('Off');
            setButtonLoading(this, false);
        });

        // Actualizar configuraci√≥n cuando cambian los inputs
        txtTempObjetivo.addEventListener('change', function() {
            objetivo = parseFloat(this.value) || 4;
            addDebugInfo(`Objetivo cambiado a: ${objetivo}¬∞C`);
        });

        txtDescanso.addEventListener('change', function() {
            descanso = parseInt(this.value) || 180;
            addDebugInfo(`Tiempo de descanso cambiado a: ${descanso}s`);
        });

        // Manejar visibilidad de la app
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                addDebugInfo('App en background - pausando timers');
                if (readingTimer) clearInterval(readingTimer);
                if (uiTimer) clearInterval(uiTimer);
            } else {
                addDebugInfo('App en foreground - reanudando');
                readingTimer = setInterval(leerDatos, 15000);
                uiTimer = setInterval(updateUI, 1000);
                setTimeout(leerDatos, 1000);
            }
        });

        // Prevenir zoom en doble tap (para APK)
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function (event) {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);

        // Prevenir selecci√≥n de texto en m√≥viles
        document.addEventListener('selectstart', function(e) {
            if (e.target.tagName !== 'INPUT') {
                e.preventDefault();
            }
        });

        // Inicializar cuando el DOM est√© listo
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                setTimeout(initialize, 500);
            });
        } else {
            setTimeout(initialize, 500);
        }
    </script>
</body>
</html>
